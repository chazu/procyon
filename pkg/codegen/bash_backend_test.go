package codegen_test

import (
	"strings"
	"testing"

	"github.com/chazu/procyon/pkg/codegen"
	"github.com/chazu/procyon/pkg/ir"
)

func TestBashBackend_SimpleClass(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Traits: []string{"Persistable"},
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
			{Name: "step", Default: ir.Value{Raw: "1"}},
		},
		Methods: []ir.Method{
			{
				Selector: "getValue",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check header
	if !strings.Contains(result, "#!/usr/bin/env bash") {
		t.Error("Missing shebang")
	}
	if !strings.Contains(result, "# Generated by Trashtalk Compiler (procyon)") {
		t.Error("Missing generator comment")
	}

	// Check metadata
	if !strings.Contains(result, "__Counter__superclass=\"Object\"") {
		t.Error("Missing superclass metadata")
	}
	if !strings.Contains(result, "__Counter__instanceVars=\"value:0 step:1\"") {
		t.Error("Missing instance vars metadata")
	}
	if !strings.Contains(result, "__Counter__traits=\"Persistable\"") {
		t.Error("Missing traits metadata")
	}

	// Check method
	if !strings.Contains(result, "__Counter__getValue()") {
		t.Error("Missing getValue method")
	}
	if !strings.Contains(result, "echo \"$(_ivar value)\"; return") {
		t.Error("Missing return statement with ivar access")
	}
}

func TestBashBackend_ClassMethod(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "description",
				Kind:     ir.ClassMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.LiteralExpr{Value: "A simple counter", Type_: ir.TypeString},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check class method naming
	if !strings.Contains(result, "__Counter__class__description()") {
		t.Error("Missing class method with correct naming")
	}
}

func TestBashBackend_KeywordMethod(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "setValue:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "val"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "value",
						Value:  &ir.VarRefExpr{Name: "val", Kind: ir.VarParam},
						Kind:   ir.AssignIVar,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check keyword method naming (: becomes _)
	if !strings.Contains(result, "__Counter__setValue_()") {
		t.Error("Missing keyword method with correct naming")
	}

	// Check parameter handling
	if !strings.Contains(result, "local val=\"$1\"") {
		t.Error("Missing parameter declaration")
	}

	// Check ivar set
	if !strings.Contains(result, "_ivar_set value \"$val\"") {
		t.Error("Missing ivar_set call")
	}
}

func TestBashBackend_MultiKeywordMethod(t *testing.T) {
	prog := &ir.Program{
		Name:   "Array",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "at:put:",
				Kind:     ir.InstanceMethod,
				Args: []ir.VarDecl{
					{Name: "index"},
					{Name: "value"},
				},
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.VarRefExpr{Name: "value", Kind: ir.VarParam},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check multi-keyword method naming
	if !strings.Contains(result, "__Array__at_put_()") {
		t.Error("Missing multi-keyword method with correct naming")
	}

	// Check multiple parameters
	if !strings.Contains(result, "local index=\"$1\"") {
		t.Error("Missing first parameter")
	}
	if !strings.Contains(result, "local value=\"$2\"") {
		t.Error("Missing second parameter")
	}
}

func TestBashBackend_LocalVariables(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "increment",
				Kind:     ir.InstanceMethod,
				Locals:   []ir.VarDecl{{Name: "newVal"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "newVal",
						Value: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
							Op:    "+",
							Right: &ir.LiteralExpr{Value: 1, Type_: ir.TypeInt},
						},
						Kind: ir.AssignLocal,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check local variable declaration
	if !strings.Contains(result, "local newVal") {
		t.Error("Missing local variable declaration")
	}
}

func TestBashBackend_MessageSend(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "increment",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ExprStmt{
						Expr: &ir.MessageSendExpr{
							Receiver:   &ir.SelfExpr{},
							Selector:   "getValue",
							IsSelfSend: true,
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check message send syntax
	if !strings.Contains(result, "@ \"$_RECEIVER\" getValue") {
		t.Error("Missing self message send with @ syntax")
	}
}

func TestBashBackend_IfStatement(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "isPositive",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.IfStmt{
						Condition: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
							Op:    ">",
							Right: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt},
						},
						ThenBlock: []ir.Statement{
							&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "true", Type_: ir.TypeString}},
						},
						ElseBlock: []ir.Statement{
							&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "false", Type_: ir.TypeString}},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check if statement structure
	if !strings.Contains(result, "if (( ") {
		t.Error("Missing if statement with arithmetic comparison")
	}
	if !strings.Contains(result, "then") {
		t.Error("Missing then keyword")
	}
	if !strings.Contains(result, "else") {
		t.Error("Missing else keyword")
	}
	if !strings.Contains(result, "fi") {
		t.Error("Missing fi keyword")
	}
}

func TestBashBackend_WhileLoop(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "countTo:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "limit"}},
				Locals:   []ir.VarDecl{{Name: "i"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "i",
						Value:  &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt},
						Kind:   ir.AssignLocal,
					},
					&ir.WhileStmt{
						Condition: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "i", Kind: ir.VarLocal},
							Op:    "<",
							Right: &ir.VarRefExpr{Name: "limit", Kind: ir.VarParam},
						},
						Body: []ir.Statement{
							&ir.AssignStmt{
								Target: "i",
								Value: &ir.BinaryExpr{
									Left:  &ir.VarRefExpr{Name: "i", Kind: ir.VarLocal},
									Op:    "+",
									Right: &ir.LiteralExpr{Value: 1, Type_: ir.TypeInt},
								},
								Kind: ir.AssignLocal,
							},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check while loop structure
	if !strings.Contains(result, "while (( ") {
		t.Error("Missing while loop with arithmetic comparison")
	}
	if !strings.Contains(result, "do") {
		t.Error("Missing do keyword")
	}
	if !strings.Contains(result, "done") {
		t.Error("Missing done keyword")
	}
}

func TestBashBackend_Namespace(t *testing.T) {
	prog := &ir.Program{
		Package: "MyApp",
		Name:    "Counter",
		Parent:  "Object",
		Methods: []ir.Method{
			{
				Selector: "getValue",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.LiteralExpr{Value: 42, Type_: ir.TypeInt},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check namespaced function naming
	if !strings.Contains(result, "__MyApp__Counter__getValue()") {
		t.Error("Missing namespaced method with correct naming")
	}
	if !strings.Contains(result, "__MyApp__Counter__superclass=\"Object\"") {
		t.Error("Missing namespaced superclass metadata")
	}
}

func TestBashBackend_IVarAccessors(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
		},
		Methods: []ir.Method{}, // No explicit methods
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check auto-generated getter
	if !strings.Contains(result, "__Counter__value()") {
		t.Error("Missing auto-generated getter")
	}
	if !strings.Contains(result, "echo \"$(_ivar value)\"; return") {
		t.Error("Missing getter implementation")
	}

	// Check auto-generated setter
	if !strings.Contains(result, "__Counter__value_()") {
		t.Error("Missing auto-generated setter")
	}
	if !strings.Contains(result, "_ivar_set value \"$1\"") {
		t.Error("Missing setter implementation")
	}
}

func TestBashBackend_BashStmt(t *testing.T) {
	prog := &ir.Program{
		Name:   "Shell",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "run",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.BashStmt{
						Code:   "ls -la | head -5",
						Reason: "Raw shell command",
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check raw bash code is preserved
	if !strings.Contains(result, "ls -la | head -5") {
		t.Error("Missing raw bash code")
	}
}

func TestBashBackend_JSONPrimitive_ArrayAt(t *testing.T) {
	prog := &ir.Program{
		Name:   "Array",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "at:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "index"}},
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.JSONPrimitiveExpr{
							Receiver:  &ir.VarRefExpr{Name: "items", Kind: ir.VarIVar},
							Operation: "arrayAt",
							Args:      []ir.Expression{&ir.VarRefExpr{Name: "index", Kind: ir.VarParam}},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check jq-based array access
	if !strings.Contains(result, "jq -r --argjson i") {
		t.Error("Missing jq array access")
	}
}

// =============================================================================
// GOLDEN/SNAPSHOT TESTS - Full Output Structure
// =============================================================================

func TestBashBackend_FullOutput_CounterClass(t *testing.T) {
	// Test a realistic Counter class matching jq-compiler output format
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Traits: []string{"Persistable"},
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
			{Name: "step", Default: ir.Value{Raw: "1"}},
		},
		Methods: []ir.Method{
			{
				Selector: "getValue",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
					},
				},
			},
			{
				Selector: "setValue:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "val"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "value",
						Value:  &ir.VarRefExpr{Name: "val", Kind: ir.VarParam},
						Kind:   ir.AssignIVar,
					},
				},
			},
			{
				Selector: "increment",
				Kind:     ir.InstanceMethod,
				Locals:   []ir.VarDecl{{Name: "newVal"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "newVal",
						Value: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
							Op:    "+",
							Right: &ir.VarRefExpr{Name: "step", Kind: ir.VarIVar},
						},
						Kind: ir.AssignLocal,
					},
					&ir.AssignStmt{
						Target: "value",
						Value:  &ir.VarRefExpr{Name: "newVal", Kind: ir.VarLocal},
						Kind:   ir.AssignIVar,
					},
					&ir.ReturnStmt{
						Value: &ir.VarRefExpr{Name: "newVal", Kind: ir.VarLocal},
					},
				},
			},
			{
				Selector: "description",
				Kind:     ir.ClassMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.LiteralExpr{Value: "A simple counter", Type_: ir.TypeString},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Verify output structure follows jq-compiler format
	lines := strings.Split(result, "\n")

	// Check header lines
	assertLineContains(t, lines, 0, "#!/usr/bin/env bash")
	assertLineContains(t, lines, 1, "# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT")
	assertLineContains(t, lines, 2, "# Source: Counter.trash")
	assertLineContains(t, lines, 3, "# Generated:")

	// Check metadata block (after empty line)
	assertContainsLine(t, result, `__Counter__superclass="Object"`)
	assertContainsLine(t, result, `__Counter__instanceVars="value:0 step:1"`)
	assertContainsLine(t, result, `__Counter__classInstanceVars=""`)
	assertContainsLine(t, result, `__Counter__traits="Persistable"`)
	assertContainsLine(t, result, `__Counter__sourceHash=`)

	// Check source embedding function
	if !strings.Contains(result, "__Counter__source() {") {
		t.Error("Missing __Counter__source() function")
	}
	if !strings.Contains(result, "__TRASHTALK_SOURCE_EOF__") {
		t.Error("Missing heredoc marker for source embedding")
	}

	// Check auto-generated ivar accessors
	if !strings.Contains(result, "__Counter__value() {") {
		t.Error("Missing value getter")
	}
	if !strings.Contains(result, "__Counter__value_() {") {
		t.Error("Missing value setter")
	}
	if !strings.Contains(result, "__Counter__step() {") {
		t.Error("Missing step getter")
	}
	if !strings.Contains(result, "__Counter__step_() {") {
		t.Error("Missing step setter")
	}

	// Check methods
	if !strings.Contains(result, "__Counter__getValue() {") {
		t.Error("Missing getValue method")
	}
	if !strings.Contains(result, "__Counter__setValue_() {") {
		t.Error("Missing setValue_ method")
	}
	if !strings.Contains(result, "__Counter__increment() {") {
		t.Error("Missing increment method")
	}
	if !strings.Contains(result, "__Counter__class__description() {") {
		t.Error("Missing class method description")
	}
}

// =============================================================================
// CLASS METADATA TESTS
// =============================================================================

func TestBashBackend_Metadata_SuperclassFormat(t *testing.T) {
	testCases := []struct {
		name     string
		parent   string
		expected string
	}{
		{"Object parent", "Object", `__TestClass__superclass="Object"`},
		{"Custom parent", "Collection", `__TestClass__superclass="Collection"`},
		{"No parent", "", `__TestClass__superclass="nil"`},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			prog := &ir.Program{
				Name:   "TestClass",
				Parent: tc.parent,
			}

			backend := codegen.NewBashBackend()
			result, err := backend.Generate(prog)
			if err != nil {
				t.Fatalf("Generate failed: %v", err)
			}

			if !strings.Contains(result, tc.expected) {
				t.Errorf("Expected %q in output, got:\n%s", tc.expected, result)
			}
		})
	}
}

func TestBashBackend_Metadata_InstanceVarsFormat(t *testing.T) {
	testCases := []struct {
		name     string
		ivars    []ir.VarDecl
		expected string
	}{
		{
			"Single ivar with default",
			[]ir.VarDecl{{Name: "count", Default: ir.Value{Raw: "0"}}},
			`__TestClass__instanceVars="count:0"`,
		},
		{
			"Multiple ivars with defaults",
			[]ir.VarDecl{
				{Name: "value", Default: ir.Value{Raw: "0"}},
				{Name: "step", Default: ir.Value{Raw: "1"}},
			},
			`__TestClass__instanceVars="value:0 step:1"`,
		},
		{
			"IVar with JSON default",
			[]ir.VarDecl{{Name: "items", Default: ir.Value{Raw: "[]"}}},
			`__TestClass__instanceVars="items:[]"`,
		},
		{
			"No ivars",
			[]ir.VarDecl{},
			`__TestClass__instanceVars=""`,
		},
		{
			"IVar without default",
			[]ir.VarDecl{{Name: "name", Default: ir.Value{Raw: ""}}},
			`__TestClass__instanceVars="name:"`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			prog := &ir.Program{
				Name:         "TestClass",
				Parent:       "Object",
				InstanceVars: tc.ivars,
			}

			backend := codegen.NewBashBackend()
			result, err := backend.Generate(prog)
			if err != nil {
				t.Fatalf("Generate failed: %v", err)
			}

			if !strings.Contains(result, tc.expected) {
				t.Errorf("Expected %q in output, got:\n%s", tc.expected, result)
			}
		})
	}
}

func TestBashBackend_Metadata_TraitsFormat(t *testing.T) {
	testCases := []struct {
		name     string
		traits   []string
		expected string
	}{
		{
			"Single trait",
			[]string{"Persistable"},
			`__TestClass__traits="Persistable"`,
		},
		{
			"Multiple traits",
			[]string{"Debuggable", "Persistable"},
			`__TestClass__traits="Debuggable Persistable"`,
		},
		{
			"No traits",
			[]string{},
			`__TestClass__traits=""`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			prog := &ir.Program{
				Name:   "TestClass",
				Parent: "Object",
				Traits: tc.traits,
			}

			backend := codegen.NewBashBackend()
			result, err := backend.Generate(prog)
			if err != nil {
				t.Fatalf("Generate failed: %v", err)
			}

			if !strings.Contains(result, tc.expected) {
				t.Errorf("Expected %q in output, got:\n%s", tc.expected, result)
			}
		})
	}
}

func TestBashBackend_Metadata_ClassInstanceVarsEmpty(t *testing.T) {
	prog := &ir.Program{
		Name:   "TestClass",
		Parent: "Object",
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Class instance vars should always be empty string for now
	if !strings.Contains(result, `__TestClass__classInstanceVars=""`) {
		t.Error("Missing empty classInstanceVars metadata")
	}
}

// =============================================================================
// IVAR ACCESSOR TESTS
// =============================================================================

func TestBashBackend_IVarAccessors_GetterFormat(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Getter should be: __Counter__value() { echo "$(_ivar value)"; return }
	expectedGetter := `__Counter__value() {
  echo "$(_ivar value)"; return
}`
	if !strings.Contains(result, expectedGetter) {
		t.Errorf("Getter format incorrect. Expected:\n%s\n\nGot:\n%s", expectedGetter, result)
	}
}

func TestBashBackend_IVarAccessors_SetterFormat(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Setter should be: __Counter__value_() { _ivar_set value "$1" }
	expectedSetter := `__Counter__value_() {
  _ivar_set value "$1"
}`
	if !strings.Contains(result, expectedSetter) {
		t.Errorf("Setter format incorrect. Expected:\n%s\n\nGot:\n%s", expectedSetter, result)
	}
}

func TestBashBackend_IVarAccessors_MultipleIVars(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
			{Name: "step", Default: ir.Value{Raw: "1"}},
			{Name: "name", Default: ir.Value{Raw: ""}},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check all accessors are generated
	accessors := []string{
		"__Counter__value()",
		"__Counter__value_()",
		"__Counter__step()",
		"__Counter__step_()",
		"__Counter__name()",
		"__Counter__name_()",
	}

	for _, acc := range accessors {
		if !strings.Contains(result, acc) {
			t.Errorf("Missing accessor: %s", acc)
		}
	}
}

func TestBashBackend_IVarAccessors_Namespaced(t *testing.T) {
	prog := &ir.Program{
		Package: "MyApp",
		Name:    "Counter",
		Parent:  "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Namespaced accessors: __MyApp__Counter__value()
	if !strings.Contains(result, "__MyApp__Counter__value()") {
		t.Error("Missing namespaced getter")
	}
	if !strings.Contains(result, "__MyApp__Counter__value_()") {
		t.Error("Missing namespaced setter")
	}
}

// =============================================================================
// METHOD SIGNATURE TESTS
// =============================================================================

func TestBashBackend_MethodSignature_Unary(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "getValue",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result, "__Counter__getValue() {") {
		t.Error("Missing unary method with correct naming")
	}
}

func TestBashBackend_MethodSignature_SingleKeyword(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "setValue:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "val"}},
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Colon becomes underscore
	if !strings.Contains(result, "__Counter__setValue_() {") {
		t.Error("Missing keyword method (colon should become underscore)")
	}

	// Parameter declaration
	if !strings.Contains(result, `local val="$1"`) {
		t.Error("Missing parameter declaration")
	}
}

func TestBashBackend_MethodSignature_MultiKeyword(t *testing.T) {
	prog := &ir.Program{
		Name:   "Array",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "at:put:",
				Kind:     ir.InstanceMethod,
				Args: []ir.VarDecl{
					{Name: "index"},
					{Name: "value"},
				},
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// at:put: becomes at_put_
	if !strings.Contains(result, "__Array__at_put_() {") {
		t.Error("Missing multi-keyword method")
	}

	// Multiple parameters with correct indices
	if !strings.Contains(result, `local index="$1"`) {
		t.Error("Missing first parameter (index)")
	}
	if !strings.Contains(result, `local value="$2"`) {
		t.Error("Missing second parameter (value)")
	}
}

func TestBashBackend_MethodSignature_ThreeKeyword(t *testing.T) {
	prog := &ir.Program{
		Name:   "Block",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "valueWith:and:and:",
				Kind:     ir.InstanceMethod,
				Args: []ir.VarDecl{
					{Name: "first"},
					{Name: "second"},
					{Name: "third"},
				},
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result, "__Block__valueWith_and_and_() {") {
		t.Error("Missing three-keyword method")
	}

	if !strings.Contains(result, `local first="$1"`) {
		t.Error("Missing first parameter")
	}
	if !strings.Contains(result, `local second="$2"`) {
		t.Error("Missing second parameter")
	}
	if !strings.Contains(result, `local third="$3"`) {
		t.Error("Missing third parameter")
	}
}

func TestBashBackend_MethodSignature_ClassMethod(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "description",
				Kind:     ir.ClassMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "test", Type_: ir.TypeString}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Class methods have "class__" prefix
	if !strings.Contains(result, "__Counter__class__description() {") {
		t.Error("Missing class method with correct naming")
	}
}

func TestBashBackend_MethodSignature_ClassMethodWithArgs(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "createWithValue:",
				Kind:     ir.ClassMethod,
				Args:     []ir.VarDecl{{Name: "initialValue"}},
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "test", Type_: ir.TypeString}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result, "__Counter__class__createWithValue_() {") {
		t.Error("Missing class method with keyword")
	}
	if !strings.Contains(result, `local initialValue="$1"`) {
		t.Error("Missing parameter in class method")
	}
}

// =============================================================================
// METHOD BODY TESTS
// =============================================================================

func TestBashBackend_MethodBody_LocalDeclarations(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "compute",
				Kind:     ir.InstanceMethod,
				Locals: []ir.VarDecl{
					{Name: "temp"},
					{Name: "result"},
					{Name: "count"},
				},
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Multiple locals on single line
	if !strings.Contains(result, "local temp result count") {
		t.Error("Missing local variable declarations")
	}
}

func TestBashBackend_MethodBody_ReturnString(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "greeting",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "Hello, World!", Type_: ir.TypeString}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Return uses echo with return
	if !strings.Contains(result, `echo "Hello, World!"; return`) {
		t.Error("Missing return statement with string")
	}
}

func TestBashBackend_MethodBody_ReturnInt(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "answer",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: 42, Type_: ir.TypeInt}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result, `echo "42"; return`) {
		t.Error("Missing return statement with integer")
	}
}

func TestBashBackend_MethodBody_ReturnIVar(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
		},
		Methods: []ir.Method{
			{
				Selector: "getValue",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// IVar access uses _ivar helper
	if !strings.Contains(result, `echo "$(_ivar value)"; return`) {
		t.Error("Missing return with ivar access")
	}
}

func TestBashBackend_MethodBody_IVarSet(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
		},
		Methods: []ir.Method{
			{
				Selector: "reset",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "value",
						Value:  &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt},
						Kind:   ir.AssignIVar,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result, `_ivar_set value "0"`) {
		t.Error("Missing _ivar_set call")
	}
}

func TestBashBackend_MethodBody_Arithmetic(t *testing.T) {
	prog := &ir.Program{
		Name:   "Calculator",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "add:to:",
				Kind:     ir.InstanceMethod,
				Args: []ir.VarDecl{
					{Name: "a"},
					{Name: "b"},
				},
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "a", Kind: ir.VarParam},
							Op:    "+",
							Right: &ir.VarRefExpr{Name: "b", Kind: ir.VarParam},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Arithmetic uses $((...))
	if !strings.Contains(result, "$(( $a + $b ))") {
		t.Error("Missing arithmetic expression")
	}
}

func TestBashBackend_MethodBody_ComplexArithmetic(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
			{Name: "step", Default: ir.Value{Raw: "1"}},
		},
		Methods: []ir.Method{
			{
				Selector: "increment",
				Kind:     ir.InstanceMethod,
				Locals:   []ir.VarDecl{{Name: "newVal"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "newVal",
						Value: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
							Op:    "+",
							Right: &ir.VarRefExpr{Name: "step", Kind: ir.VarIVar},
						},
						Kind: ir.AssignLocal,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// IVar references in arithmetic
	if !strings.Contains(result, "$(_ivar value) + $(_ivar step)") {
		t.Error("Missing arithmetic with ivar references")
	}
}

func TestBashBackend_MethodBody_BareReturn(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "doNothing",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: nil},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Bare return (no echo)
	if !strings.Contains(result, "  return\n}") {
		t.Error("Missing bare return statement")
	}
}

// =============================================================================
// CONTROL FLOW TESTS
// =============================================================================

func TestBashBackend_ControlFlow_IfWithoutElse(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
		},
		Methods: []ir.Method{
			{
				Selector: "checkPositive",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.IfStmt{
						Condition: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
							Op:    ">",
							Right: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt},
						},
						ThenBlock: []ir.Statement{
							&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "positive", Type_: ir.TypeString}},
						},
						ElseBlock: nil,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Should have if/then/fi but no else
	if !strings.Contains(result, "if ((") {
		t.Error("Missing if statement")
	}
	if !strings.Contains(result, "then") {
		t.Error("Missing then keyword")
	}
	if !strings.Contains(result, "fi") {
		t.Error("Missing fi keyword")
	}
	if strings.Contains(result, "else") {
		t.Error("Should not have else clause")
	}
}

func TestBashBackend_ControlFlow_IfWithElse(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
		},
		Methods: []ir.Method{
			{
				Selector: "isPositive",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.IfStmt{
						Condition: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
							Op:    ">",
							Right: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt},
						},
						ThenBlock: []ir.Statement{
							&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "true", Type_: ir.TypeString}},
						},
						ElseBlock: []ir.Statement{
							&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "false", Type_: ir.TypeString}},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check complete structure
	if !strings.Contains(result, "if ((") {
		t.Error("Missing if statement")
	}
	if !strings.Contains(result, "then") {
		t.Error("Missing then keyword")
	}
	if !strings.Contains(result, "else") {
		t.Error("Missing else keyword")
	}
	if !strings.Contains(result, "fi") {
		t.Error("Missing fi keyword")
	}
}

func TestBashBackend_ControlFlow_WhileLoop(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "countTo:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "limit"}},
				Locals:   []ir.VarDecl{{Name: "i"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "i",
						Value:  &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt},
						Kind:   ir.AssignLocal,
					},
					&ir.WhileStmt{
						Condition: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "i", Kind: ir.VarLocal},
							Op:    "<",
							Right: &ir.VarRefExpr{Name: "limit", Kind: ir.VarParam},
						},
						Body: []ir.Statement{
							&ir.AssignStmt{
								Target: "i",
								Value: &ir.BinaryExpr{
									Left:  &ir.VarRefExpr{Name: "i", Kind: ir.VarLocal},
									Op:    "+",
									Right: &ir.LiteralExpr{Value: 1, Type_: ir.TypeInt},
								},
								Kind: ir.AssignLocal,
							},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check while loop structure
	if !strings.Contains(result, "while ((") {
		t.Error("Missing while statement")
	}
	if !strings.Contains(result, "do") {
		t.Error("Missing do keyword")
	}
	if !strings.Contains(result, "done") {
		t.Error("Missing done keyword")
	}
}

func TestBashBackend_ControlFlow_ForEachLoop(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "printEach:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "items"}},
				Body: []ir.Statement{
					&ir.ForEachStmt{
						IterVar:    "item",
						Collection: &ir.VarRefExpr{Name: "items", Kind: ir.VarParam},
						Body: []ir.Statement{
							&ir.ExprStmt{
								Expr: &ir.MessageSendExpr{
									Receiver:    &ir.SelfExpr{},
									Selector:    "print:",
									Args:        []ir.Expression{&ir.VarRefExpr{Name: "item", Kind: ir.VarLocal}},
									IsSelfSend:  true,
								},
							},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check for-each structure
	if !strings.Contains(result, "for item in") {
		t.Error("Missing for-each statement")
	}
	if !strings.Contains(result, "do") {
		t.Error("Missing do keyword")
	}
	if !strings.Contains(result, "done") {
		t.Error("Missing done keyword")
	}
}

func TestBashBackend_ControlFlow_ProperIndentation(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "test",
				Kind:     ir.InstanceMethod,
				Locals:   []ir.VarDecl{{Name: "x"}},
				Body: []ir.Statement{
					&ir.IfStmt{
						Condition: &ir.LiteralExpr{Value: true, Type_: ir.TypeBool},
						ThenBlock: []ir.Statement{
							&ir.AssignStmt{
								Target: "x",
								Value:  &ir.LiteralExpr{Value: 1, Type_: ir.TypeInt},
								Kind:   ir.AssignLocal,
							},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Method body should be indented with 2 spaces
	if !strings.Contains(result, "\n  local x\n") {
		t.Error("Local declaration should be indented with 2 spaces")
	}

	// Content inside if should be indented with 4 spaces
	if !strings.Contains(result, "\n    x=") {
		t.Error("Content inside if should be indented with 4 spaces")
	}
}

// =============================================================================
// MESSAGE SEND TESTS
// =============================================================================

func TestBashBackend_MessageSend_SelfSend(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "doubleIncrement",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ExprStmt{
						Expr: &ir.MessageSendExpr{
							Receiver:   &ir.SelfExpr{},
							Selector:   "increment",
							IsSelfSend: true,
						},
					},
					&ir.ExprStmt{
						Expr: &ir.MessageSendExpr{
							Receiver:   &ir.SelfExpr{},
							Selector:   "increment",
							IsSelfSend: true,
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Self sends use "$_RECEIVER"
	if !strings.Contains(result, `@ "$_RECEIVER" increment`) {
		t.Error("Missing self message send with @ syntax")
	}
}

func TestBashBackend_MessageSend_SelfSendWithArgs(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "incrementByTen",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ExprStmt{
						Expr: &ir.MessageSendExpr{
							Receiver:   &ir.SelfExpr{},
							Selector:   "incrementBy:",
							Args:       []ir.Expression{&ir.LiteralExpr{Value: 10, Type_: ir.TypeInt}},
							IsSelfSend: true,
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result, `@ "$_RECEIVER" incrementBy_ 10`) {
		t.Error("Missing self message send with arguments")
	}
}

func TestBashBackend_MessageSend_ExternalReceiver(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "callOther:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "other"}},
				Body: []ir.Statement{
					&ir.ExprStmt{
						Expr: &ir.MessageSendExpr{
							Receiver: &ir.VarRefExpr{Name: "other", Kind: ir.VarParam},
							Selector: "doSomething",
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// External sends quote the variable receiver
	if !strings.Contains(result, `@ "$other" doSomething`) {
		t.Error("Missing external message send")
	}
}

func TestBashBackend_MessageSend_ClassSend(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "createCounter",
				Kind:     ir.InstanceMethod,
				Locals:   []ir.VarDecl{{Name: "counter"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "counter",
						Value: &ir.MessageSendExpr{
							Receiver:    &ir.ClassRefExpr{Name: "Counter"},
							Selector:    "new",
							IsClassSend: true,
							TargetClass: "Counter",
						},
						Kind: ir.AssignLocal,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Class sends use class name directly
	if !strings.Contains(result, "$(@ Counter new)") {
		t.Error("Missing class message send")
	}
}

func TestBashBackend_MessageSend_NestedInExpression(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "getValueFrom:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "obj"}},
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.MessageSendExpr{
							Receiver: &ir.VarRefExpr{Name: "obj", Kind: ir.VarParam},
							Selector: "getValue",
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Nested message send captured in $()
	if !strings.Contains(result, `echo "$(@ "$obj" getValue)"; return`) {
		t.Error("Missing nested message send in return")
	}
}

// =============================================================================
// NAMESPACE TESTS
// =============================================================================

func TestBashBackend_Namespace_Metadata(t *testing.T) {
	prog := &ir.Program{
		Package: "MyApp",
		Name:    "Counter",
		Parent:  "Object",
		Traits:  []string{"Persistable"},
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// All metadata should use namespaced name
	if !strings.Contains(result, `__MyApp__Counter__superclass="Object"`) {
		t.Error("Missing namespaced superclass")
	}
	if !strings.Contains(result, `__MyApp__Counter__instanceVars="value:0"`) {
		t.Error("Missing namespaced instanceVars")
	}
	if !strings.Contains(result, `__MyApp__Counter__traits="Persistable"`) {
		t.Error("Missing namespaced traits")
	}
}

func TestBashBackend_Namespace_SourceFunction(t *testing.T) {
	prog := &ir.Program{
		Package: "MyApp",
		Name:    "Counter",
		Parent:  "Object",
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result, "__MyApp__Counter__source() {") {
		t.Error("Missing namespaced source function")
	}
}

func TestBashBackend_Namespace_Methods(t *testing.T) {
	prog := &ir.Program{
		Package: "MyApp",
		Name:    "Counter",
		Parent:  "Object",
		Methods: []ir.Method{
			{
				Selector: "getValue",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt}},
				},
			},
			{
				Selector: "setValue:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "val"}},
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt}},
				},
			},
			{
				Selector: "description",
				Kind:     ir.ClassMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "test", Type_: ir.TypeString}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Instance methods
	if !strings.Contains(result, "__MyApp__Counter__getValue() {") {
		t.Error("Missing namespaced instance method")
	}
	if !strings.Contains(result, "__MyApp__Counter__setValue_() {") {
		t.Error("Missing namespaced keyword method")
	}
	// Class methods
	if !strings.Contains(result, "__MyApp__Counter__class__description() {") {
		t.Error("Missing namespaced class method")
	}
}

func TestBashBackend_Namespace_QualifiedParent(t *testing.T) {
	prog := &ir.Program{
		Package:       "MyApp",
		Name:          "Counter",
		Parent:        "Collection",
		ParentPackage: "Core",
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Parent should just be the class name (runtime handles resolution)
	if !strings.Contains(result, `__MyApp__Counter__superclass="Collection"`) {
		t.Error("Missing parent reference")
	}
}

// =============================================================================
// EDGE CASE TESTS
// =============================================================================

func TestBashBackend_EdgeCase_EmptyClass(t *testing.T) {
	prog := &ir.Program{
		Name:   "EmptyClass",
		Parent: "Object",
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Should still have header and metadata
	if !strings.Contains(result, "#!/usr/bin/env bash") {
		t.Error("Missing shebang")
	}
	if !strings.Contains(result, `__EmptyClass__superclass="Object"`) {
		t.Error("Missing superclass")
	}
	if !strings.Contains(result, `__EmptyClass__instanceVars=""`) {
		t.Error("Missing empty instanceVars")
	}
	if !strings.Contains(result, "__EmptyClass__source() {") {
		t.Error("Missing source function")
	}
}

func TestBashBackend_EdgeCase_OnlyClassMethods(t *testing.T) {
	prog := &ir.Program{
		Name:   "Utility",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "version",
				Kind:     ir.ClassMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "1.0.0", Type_: ir.TypeString}},
				},
			},
			{
				Selector: "author",
				Kind:     ir.ClassMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "Test", Type_: ir.TypeString}},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Should only have class methods
	if !strings.Contains(result, "__Utility__class__version() {") {
		t.Error("Missing version class method")
	}
	if !strings.Contains(result, "__Utility__class__author() {") {
		t.Error("Missing author class method")
	}
}

func TestBashBackend_EdgeCase_MethodNoParamsNoLocals(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "noop",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{},
				Locals:   []ir.VarDecl{},
				Body:     []ir.Statement{},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Method should still be generated, just empty
	if !strings.Contains(result, "__Test__noop() {\n}") {
		t.Error("Missing empty method")
	}
}

func TestBashBackend_EdgeCase_RawBashCode(t *testing.T) {
	prog := &ir.Program{
		Name:   "Shell",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "runCommand",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.BashStmt{
						Code:   "ls -la /tmp",
						Reason: "Direct shell access",
					},
					&ir.BashStmt{
						Code:   "echo \"Done\"",
						Reason: "Status message",
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Raw bash should be preserved exactly
	if !strings.Contains(result, "ls -la /tmp") {
		t.Error("Missing first raw bash command")
	}
	if !strings.Contains(result, `echo "Done"`) {
		t.Error("Missing second raw bash command")
	}
}

func TestBashBackend_EdgeCase_SpecialCharactersInStrings(t *testing.T) {
	prog := &ir.Program{
		Name:   "Test",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "getMessage",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.LiteralExpr{Value: "Hello $USER", Type_: ir.TypeString},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// String should be in output (quoting handled by caller)
	if !strings.Contains(result, "Hello $USER") {
		t.Error("Missing string with special characters")
	}
}

func TestBashBackend_EdgeCase_ClassVarAssignment(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		ClassVars: []ir.VarDecl{
			{Name: "count", Default: ir.Value{Raw: "0"}},
		},
		Methods: []ir.Method{
			{
				Selector: "incrementClassCount",
				Kind:     ir.ClassMethod,
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "count",
						Value:  &ir.LiteralExpr{Value: 1, Type_: ir.TypeInt},
						Kind:   ir.AssignClassVar,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Class var assignment uses global with prefix
	if !strings.Contains(result, `__Counter__count="1"`) {
		t.Error("Missing class variable assignment")
	}
}

func TestBashBackend_EdgeCase_ClassVarReference(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		ClassVars: []ir.VarDecl{
			{Name: "count", Default: ir.Value{Raw: "0"}},
		},
		Methods: []ir.Method{
			{
				Selector: "getClassCount",
				Kind:     ir.ClassMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.VarRefExpr{Name: "count", Kind: ir.VarClassVar},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Class var reference uses ${__ClassName__varName}
	if !strings.Contains(result, "${__Counter__count}") {
		t.Error("Missing class variable reference")
	}
}

// =============================================================================
// JSON PRIMITIVE OPERATION TESTS
// =============================================================================

func TestBashBackend_JSONPrimitive_ArrayPush(t *testing.T) {
	prog := &ir.Program{
		Name:   "Array",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "items", Default: ir.Value{Raw: "[]"}},
		},
		Methods: []ir.Method{
			{
				Selector: "push:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "value"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "items",
						Value: &ir.JSONPrimitiveExpr{
							Receiver:  &ir.VarRefExpr{Name: "items", Kind: ir.VarIVar},
							Operation: "arrayPush",
							Args:      []ir.Expression{&ir.VarRefExpr{Name: "value", Kind: ir.VarParam}},
						},
						Kind: ir.AssignIVar,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result, "jq -c --arg v") {
		t.Error("Missing jq array push")
	}
	if !strings.Contains(result, ". + [$v]") {
		t.Error("Missing jq array push expression")
	}
}

func TestBashBackend_JSONPrimitive_ArrayLength(t *testing.T) {
	prog := &ir.Program{
		Name:   "Array",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "items", Default: ir.Value{Raw: "[]"}},
		},
		Methods: []ir.Method{
			{
				Selector: "size",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.JSONPrimitiveExpr{
							Receiver:  &ir.VarRefExpr{Name: "items", Kind: ir.VarIVar},
							Operation: "arrayLength",
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result, "jq 'length'") {
		t.Error("Missing jq array length")
	}
}

func TestBashBackend_JSONPrimitive_ObjectAtPut(t *testing.T) {
	prog := &ir.Program{
		Name:   "Dictionary",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "data", Default: ir.Value{Raw: "{}"}},
		},
		Methods: []ir.Method{
			{
				Selector: "at:put:",
				Kind:     ir.InstanceMethod,
				Args: []ir.VarDecl{
					{Name: "key"},
					{Name: "value"},
				},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "data",
						Value: &ir.JSONPrimitiveExpr{
							Receiver:  &ir.VarRefExpr{Name: "data", Kind: ir.VarIVar},
							Operation: "objectAtPut",
							Args: []ir.Expression{
								&ir.VarRefExpr{Name: "key", Kind: ir.VarParam},
								&ir.VarRefExpr{Name: "value", Kind: ir.VarParam},
							},
						},
						Kind: ir.AssignIVar,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result, "jq -c --arg k") {
		t.Error("Missing jq object at put")
	}
	if !strings.Contains(result, ". + {($k): $v}") {
		t.Error("Missing jq object merge expression")
	}
}

// =============================================================================
// HELPER FUNCTIONS FOR TESTS
// =============================================================================

func assertLineContains(t *testing.T, lines []string, index int, expected string) {
	t.Helper()
	if index >= len(lines) {
		t.Errorf("Line index %d out of range (only %d lines)", index, len(lines))
		return
	}
	if !strings.Contains(lines[index], expected) {
		t.Errorf("Line %d: expected to contain %q, got %q", index, expected, lines[index])
	}
}

func assertContainsLine(t *testing.T, output, expected string) {
	t.Helper()
	if !strings.Contains(output, expected) {
		t.Errorf("Expected output to contain:\n  %s\n\nGot:\n%s", expected, output)
	}
}
