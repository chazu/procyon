package codegen_test

import (
	"strings"
	"testing"

	"github.com/chazu/procyon/pkg/codegen"
	"github.com/chazu/procyon/pkg/ir"
)

func TestBashBackend_SimpleClass(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Traits: []string{"Persistable"},
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
			{Name: "step", Default: ir.Value{Raw: "1"}},
		},
		Methods: []ir.Method{
			{
				Selector: "getValue",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check header
	if !strings.Contains(result, "#!/usr/bin/env bash") {
		t.Error("Missing shebang")
	}
	if !strings.Contains(result, "# Generated by Trashtalk Compiler (procyon)") {
		t.Error("Missing generator comment")
	}

	// Check metadata
	if !strings.Contains(result, "__Counter__superclass=\"Object\"") {
		t.Error("Missing superclass metadata")
	}
	if !strings.Contains(result, "__Counter__instanceVars=\"value:0 step:1\"") {
		t.Error("Missing instance vars metadata")
	}
	if !strings.Contains(result, "__Counter__traits=\"Persistable\"") {
		t.Error("Missing traits metadata")
	}

	// Check method
	if !strings.Contains(result, "__Counter__getValue()") {
		t.Error("Missing getValue method")
	}
	if !strings.Contains(result, "echo \"$(_ivar value)\"; return") {
		t.Error("Missing return statement with ivar access")
	}
}

func TestBashBackend_ClassMethod(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "description",
				Kind:     ir.ClassMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.LiteralExpr{Value: "A simple counter", Type_: ir.TypeString},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check class method naming
	if !strings.Contains(result, "__Counter__class__description()") {
		t.Error("Missing class method with correct naming")
	}
}

func TestBashBackend_KeywordMethod(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "setValue:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "val"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "value",
						Value:  &ir.VarRefExpr{Name: "val", Kind: ir.VarParam},
						Kind:   ir.AssignIVar,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check keyword method naming (: becomes _)
	if !strings.Contains(result, "__Counter__setValue_()") {
		t.Error("Missing keyword method with correct naming")
	}

	// Check parameter handling
	if !strings.Contains(result, "local val=\"$1\"") {
		t.Error("Missing parameter declaration")
	}

	// Check ivar set
	if !strings.Contains(result, "_ivar_set value \"$val\"") {
		t.Error("Missing ivar_set call")
	}
}

func TestBashBackend_MultiKeywordMethod(t *testing.T) {
	prog := &ir.Program{
		Name:   "Array",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "at:put:",
				Kind:     ir.InstanceMethod,
				Args: []ir.VarDecl{
					{Name: "index"},
					{Name: "value"},
				},
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.VarRefExpr{Name: "value", Kind: ir.VarParam},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check multi-keyword method naming
	if !strings.Contains(result, "__Array__at_put_()") {
		t.Error("Missing multi-keyword method with correct naming")
	}

	// Check multiple parameters
	if !strings.Contains(result, "local index=\"$1\"") {
		t.Error("Missing first parameter")
	}
	if !strings.Contains(result, "local value=\"$2\"") {
		t.Error("Missing second parameter")
	}
}

func TestBashBackend_LocalVariables(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "increment",
				Kind:     ir.InstanceMethod,
				Locals:   []ir.VarDecl{{Name: "newVal"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "newVal",
						Value: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
							Op:    "+",
							Right: &ir.LiteralExpr{Value: 1, Type_: ir.TypeInt},
						},
						Kind: ir.AssignLocal,
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check local variable declaration
	if !strings.Contains(result, "local newVal") {
		t.Error("Missing local variable declaration")
	}
}

func TestBashBackend_MessageSend(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "increment",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ExprStmt{
						Expr: &ir.MessageSendExpr{
							Receiver:   &ir.SelfExpr{},
							Selector:   "getValue",
							IsSelfSend: true,
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check message send syntax
	if !strings.Contains(result, "@ \"$_RECEIVER\" getValue") {
		t.Error("Missing self message send with @ syntax")
	}
}

func TestBashBackend_IfStatement(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "isPositive",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.IfStmt{
						Condition: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "value", Kind: ir.VarIVar},
							Op:    ">",
							Right: &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt},
						},
						ThenBlock: []ir.Statement{
							&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "true", Type_: ir.TypeString}},
						},
						ElseBlock: []ir.Statement{
							&ir.ReturnStmt{Value: &ir.LiteralExpr{Value: "false", Type_: ir.TypeString}},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check if statement structure
	if !strings.Contains(result, "if (( ") {
		t.Error("Missing if statement with arithmetic comparison")
	}
	if !strings.Contains(result, "then") {
		t.Error("Missing then keyword")
	}
	if !strings.Contains(result, "else") {
		t.Error("Missing else keyword")
	}
	if !strings.Contains(result, "fi") {
		t.Error("Missing fi keyword")
	}
}

func TestBashBackend_WhileLoop(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "countTo:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "limit"}},
				Locals:   []ir.VarDecl{{Name: "i"}},
				Body: []ir.Statement{
					&ir.AssignStmt{
						Target: "i",
						Value:  &ir.LiteralExpr{Value: 0, Type_: ir.TypeInt},
						Kind:   ir.AssignLocal,
					},
					&ir.WhileStmt{
						Condition: &ir.BinaryExpr{
							Left:  &ir.VarRefExpr{Name: "i", Kind: ir.VarLocal},
							Op:    "<",
							Right: &ir.VarRefExpr{Name: "limit", Kind: ir.VarParam},
						},
						Body: []ir.Statement{
							&ir.AssignStmt{
								Target: "i",
								Value: &ir.BinaryExpr{
									Left:  &ir.VarRefExpr{Name: "i", Kind: ir.VarLocal},
									Op:    "+",
									Right: &ir.LiteralExpr{Value: 1, Type_: ir.TypeInt},
								},
								Kind: ir.AssignLocal,
							},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check while loop structure
	if !strings.Contains(result, "while (( ") {
		t.Error("Missing while loop with arithmetic comparison")
	}
	if !strings.Contains(result, "do") {
		t.Error("Missing do keyword")
	}
	if !strings.Contains(result, "done") {
		t.Error("Missing done keyword")
	}
}

func TestBashBackend_Namespace(t *testing.T) {
	prog := &ir.Program{
		Package: "MyApp",
		Name:    "Counter",
		Parent:  "Object",
		Methods: []ir.Method{
			{
				Selector: "getValue",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.LiteralExpr{Value: 42, Type_: ir.TypeInt},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check namespaced function naming
	if !strings.Contains(result, "__MyApp__Counter__getValue()") {
		t.Error("Missing namespaced method with correct naming")
	}
	if !strings.Contains(result, "__MyApp__Counter__superclass=\"Object\"") {
		t.Error("Missing namespaced superclass metadata")
	}
}

func TestBashBackend_IVarAccessors(t *testing.T) {
	prog := &ir.Program{
		Name:   "Counter",
		Parent: "Object",
		InstanceVars: []ir.VarDecl{
			{Name: "value", Default: ir.Value{Raw: "0"}},
		},
		Methods: []ir.Method{}, // No explicit methods
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check auto-generated getter
	if !strings.Contains(result, "__Counter__value()") {
		t.Error("Missing auto-generated getter")
	}
	if !strings.Contains(result, "echo \"$(_ivar value)\"; return") {
		t.Error("Missing getter implementation")
	}

	// Check auto-generated setter
	if !strings.Contains(result, "__Counter__value_()") {
		t.Error("Missing auto-generated setter")
	}
	if !strings.Contains(result, "_ivar_set value \"$1\"") {
		t.Error("Missing setter implementation")
	}
}

func TestBashBackend_BashStmt(t *testing.T) {
	prog := &ir.Program{
		Name:   "Shell",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "run",
				Kind:     ir.InstanceMethod,
				Body: []ir.Statement{
					&ir.BashStmt{
						Code:   "ls -la | head -5",
						Reason: "Raw shell command",
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check raw bash code is preserved
	if !strings.Contains(result, "ls -la | head -5") {
		t.Error("Missing raw bash code")
	}
}

func TestBashBackend_JSONPrimitive_ArrayAt(t *testing.T) {
	prog := &ir.Program{
		Name:   "Array",
		Parent: "Object",
		Methods: []ir.Method{
			{
				Selector: "at:",
				Kind:     ir.InstanceMethod,
				Args:     []ir.VarDecl{{Name: "index"}},
				Body: []ir.Statement{
					&ir.ReturnStmt{
						Value: &ir.JSONPrimitiveExpr{
							Receiver:  &ir.VarRefExpr{Name: "items", Kind: ir.VarIVar},
							Operation: "arrayAt",
							Args:      []ir.Expression{&ir.VarRefExpr{Name: "index", Kind: ir.VarParam}},
						},
					},
				},
			},
		},
	}

	backend := codegen.NewBashBackend()
	result, err := backend.Generate(prog)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Check jq-based array access
	if !strings.Contains(result, "jq -r --argjson i") {
		t.Error("Missing jq array access")
	}
}
