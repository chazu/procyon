// Package codegen provides code generation backends for Trashtalk IR.
// This file implements the Bash backend, producing compiled Bash from IR.
package codegen

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"
	"time"

	"github.com/chazu/procyon/pkg/ir"
)

// BashBackend generates Bash code from Trashtalk IR.
type BashBackend struct {
	prog         *ir.Program
	buf          strings.Builder
	indent       int
	instanceVars map[string]bool // Track instance variable names for accessor generation
}

// NewBashBackend creates a new Bash code generator.
func NewBashBackend() *BashBackend {
	return &BashBackend{
		instanceVars: make(map[string]bool),
	}
}

// Generate produces Bash source code from a Trashtalk IR Program.
func (b *BashBackend) Generate(prog *ir.Program) (string, error) {
	b.prog = prog
	b.buf.Reset()
	b.indent = 0

	// Build instance var lookup
	b.instanceVars = make(map[string]bool)
	for _, iv := range prog.InstanceVars {
		b.instanceVars[iv.Name] = true
	}

	// Generate header
	b.generateHeader()

	// Generate metadata variables
	b.generateMetadata()

	// Generate source embedding
	b.generateSourceEmbedding()

	// Generate instance variable accessors
	b.generateIVarAccessors()

	// Generate methods
	for _, m := range prog.Methods {
		if err := b.generateMethod(&m); err != nil {
			return "", fmt.Errorf("generating method %s: %w", m.Selector, err)
		}
	}

	return b.buf.String(), nil
}

// generateHeader writes the file header
func (b *BashBackend) generateHeader() {
	b.writeln("#!/usr/bin/env bash")
	b.writeln("# Generated by Trashtalk Compiler (procyon) - DO NOT EDIT")
	b.writef("# Source: %s.trash\n", b.prog.Name)
	b.writef("# Generated: %s\n", time.Now().Format("2006-01-02T15:04:05"))
	b.writeln("")
}

// generateMetadata writes class metadata variables
func (b *BashBackend) generateMetadata() {
	className := b.className()
	parent := b.prog.Parent
	if parent == "" {
		parent = "nil"
	}

	// Instance vars in "name:default" format
	ivarStr := b.formatInstanceVars()

	// Traits as space-separated list
	traitsStr := strings.Join(b.prog.Traits, " ")

	// Compute source hash (placeholder - actual source would be needed)
	hash := b.computeSourceHash()

	b.writef("__%s__superclass=\"%s\"\n", className, parent)
	b.writef("__%s__instanceVars=\"%s\"\n", className, ivarStr)
	b.writef("__%s__classInstanceVars=\"\"\n", className)
	b.writef("__%s__traits=\"%s\"\n", className, traitsStr)
	b.writef("__%s__sourceHash=\"%s\"\n", className, hash)
	b.writeln("")
}

// generateSourceEmbedding writes the source embedding function
func (b *BashBackend) generateSourceEmbedding() {
	className := b.className()

	b.writef("__%s__source() {\n", className)
	b.indent++
	b.writeln("cat <<'__TRASHTALK_SOURCE_EOF__'")
	// Note: heredoc content must not have leading indentation for the terminator
	b.buf.WriteString("# Source not available in IR compilation mode\n")
	b.buf.WriteString("__TRASHTALK_SOURCE_EOF__\n")
	b.indent--
	b.writeln("}")
	b.writeln("")
}

// generateIVarAccessors generates getter/setter methods for instance variables
func (b *BashBackend) generateIVarAccessors() {
	className := b.className()

	for _, iv := range b.prog.InstanceVars {
		// Getter: __Counter__value()
		b.writef("__%s__%s() {\n", className, iv.Name)
		b.indent++
		b.writef("echo \"$(_ivar %s)\"; return\n", iv.Name)
		b.indent--
		b.writeln("}")
		b.writeln("")

		// Setter: __Counter__value_()
		b.writef("__%s__%s_() {\n", className, iv.Name)
		b.indent++
		b.writef("_ivar_set %s \"$1\"\n", iv.Name)
		b.indent--
		b.writeln("}")
		b.writeln("")
	}
}

// generateMethod generates a single method
func (b *BashBackend) generateMethod(m *ir.Method) error {
	className := b.className()
	funcName := b.methodFuncName(m)

	b.writef("__%s__%s() {\n", className, funcName)
	b.indent++

	// For raw methods, emit the raw Bash body directly
	if m.IsRaw && m.RawBody != "" {
		// Write each line of the raw body with proper indentation
		lines := strings.Split(m.RawBody, "\n")
		for _, line := range lines {
			trimmed := strings.TrimSpace(line)
			if trimmed != "" {
				b.writef("%s\n", trimmed)
			}
		}
		b.indent--
		b.writeln("}")
		b.writeln("")
		return nil
	}

	// Declare parameters
	for i, arg := range m.Args {
		b.writef("local %s=\"$%d\"\n", arg.Name, i+1)
	}

	// Declare local variables
	if len(m.Locals) > 0 {
		var names []string
		for _, l := range m.Locals {
			names = append(names, l.Name)
		}
		b.writef("local %s\n", strings.Join(names, " "))
	}

	// Generate body statements
	for _, stmt := range m.Body {
		if err := b.generateStatement(stmt); err != nil {
			return err
		}
	}

	b.indent--
	b.writeln("}")
	b.writeln("")

	return nil
}

// generateStatement generates a single statement
func (b *BashBackend) generateStatement(stmt ir.Statement) error {
	switch s := stmt.(type) {
	case *ir.AssignStmt:
		return b.generateAssign(s)
	case *ir.ReturnStmt:
		return b.generateReturn(s)
	case *ir.ExprStmt:
		return b.generateExprStmt(s)
	case *ir.IfStmt:
		return b.generateIf(s)
	case *ir.WhileStmt:
		return b.generateWhile(s)
	case *ir.ForEachStmt:
		return b.generateForEach(s)
	case *ir.BashStmt:
		return b.generateBashStmt(s)
	default:
		return fmt.Errorf("unsupported statement type: %T", stmt)
	}
}

// generateAssign generates an assignment statement
func (b *BashBackend) generateAssign(s *ir.AssignStmt) error {
	// Check for arithmetic expressions - use (( )) without subshell for Procyon compatibility
	if isArithmeticExpr(s.Value) {
		arithExpr, err := b.generateArithExpr(s.Value)
		if err != nil {
			return err
		}

		switch s.Kind {
		case ir.AssignIVar:
			// For ivars: use temp var pattern to avoid subshell
			b.writef("local __arith__; (( __arith__ = %s )); _ivar_set %s \"$__arith__\"\n", arithExpr, s.Target)
		case ir.AssignClassVar:
			// For cvars: use temp var pattern to avoid subshell
			b.writef("local __arith__; (( __arith__ = %s )); __%s__%s=\"$__arith__\"\n", arithExpr, b.className(), s.Target)
		default:
			// For locals: use (( var = expr )) directly
			b.writef("(( %s = %s ))\n", s.Target, arithExpr)
		}
		return nil
	}

	// Non-arithmetic assignment - use normal generation
	exprStr, err := b.generateExpr(s.Value)
	if err != nil {
		return err
	}

	switch s.Kind {
	case ir.AssignIVar:
		b.writef("_ivar_set %s \"%s\"\n", s.Target, exprStr)
	case ir.AssignClassVar:
		// Class variables use Bash globals with prefix
		b.writef("__%s__%s=\"%s\"\n", b.className(), s.Target, exprStr)
	default:
		// Local variable
		b.writef("%s=\"%s\"\n", s.Target, exprStr)
	}

	return nil
}

// generateReturn generates a return statement
func (b *BashBackend) generateReturn(s *ir.ReturnStmt) error {
	if s.Value == nil {
		b.writeln("return")
		return nil
	}

	exprStr, err := b.generateExpr(s.Value)
	if err != nil {
		return err
	}

	b.writef("echo \"%s\"; return\n", exprStr)
	return nil
}

// generateExprStmt generates an expression statement
func (b *BashBackend) generateExprStmt(s *ir.ExprStmt) error {
	exprStr, err := b.generateExpr(s.Expr)
	if err != nil {
		return err
	}

	// If it's a message send, we need to invoke it
	if _, ok := s.Expr.(*ir.MessageSendExpr); ok {
		b.writef("%s\n", exprStr)
	} else {
		// Other expressions that have side effects
		b.writef("%s\n", exprStr)
	}

	return nil
}

// generateIf generates an if statement
func (b *BashBackend) generateIf(s *ir.IfStmt) error {
	condStr, err := b.generateCondition(s.Condition)
	if err != nil {
		return err
	}

	b.writef("if %s; then\n", condStr)
	b.indent++

	for _, stmt := range s.ThenBlock {
		if err := b.generateStatement(stmt); err != nil {
			return err
		}
	}

	b.indent--

	if len(s.ElseBlock) > 0 {
		b.writeln("else")
		b.indent++
		for _, stmt := range s.ElseBlock {
			if err := b.generateStatement(stmt); err != nil {
				return err
			}
		}
		b.indent--
	}

	b.writeln("fi")
	return nil
}

// generateWhile generates a while loop
func (b *BashBackend) generateWhile(s *ir.WhileStmt) error {
	condStr, err := b.generateCondition(s.Condition)
	if err != nil {
		return err
	}

	b.writef("while %s; do\n", condStr)
	b.indent++

	for _, stmt := range s.Body {
		if err := b.generateStatement(stmt); err != nil {
			return err
		}
	}

	b.indent--
	b.writeln("done")
	return nil
}

// generateForEach generates a for-each loop
func (b *BashBackend) generateForEach(s *ir.ForEachStmt) error {
	collExpr, err := b.generateExpr(s.Collection)
	if err != nil {
		return err
	}

	b.writef("for %s in %s; do\n", s.IterVar, collExpr)
	b.indent++

	for _, stmt := range s.Body {
		if err := b.generateStatement(stmt); err != nil {
			return err
		}
	}

	b.indent--
	b.writeln("done")
	return nil
}

// generateBashStmt generates raw Bash code
func (b *BashBackend) generateBashStmt(s *ir.BashStmt) error {
	// Raw bash code is written directly
	b.writef("%s\n", s.Code)
	return nil
}

// generateCondition generates a bash condition expression
func (b *BashBackend) generateCondition(expr ir.Expression) (string, error) {
	switch e := expr.(type) {
	case *ir.BinaryExpr:
		left, err := b.generateExpr(e.Left)
		if err != nil {
			return "", err
		}
		right, err := b.generateExpr(e.Right)
		if err != nil {
			return "", err
		}

		// Map operators to bash test operators
		switch e.Op {
		case "==":
			return fmt.Sprintf("[[ \"$%s\" == \"%s\" ]]", stripDollar(left), right), nil
		case "!=":
			return fmt.Sprintf("[[ \"$%s\" != \"%s\" ]]", stripDollar(left), right), nil
		case "<":
			return fmt.Sprintf("(( $%s < %s ))", stripDollar(left), right), nil
		case ">":
			return fmt.Sprintf("(( $%s > %s ))", stripDollar(left), right), nil
		case "<=":
			return fmt.Sprintf("(( $%s <= %s ))", stripDollar(left), right), nil
		case ">=":
			return fmt.Sprintf("(( $%s >= %s ))", stripDollar(left), right), nil
		default:
			return fmt.Sprintf("[[ %s %s %s ]]", left, e.Op, right), nil
		}
	case *ir.LiteralExpr:
		// Boolean literal
		if e.Type_ == ir.TypeBool {
			if v, ok := e.Value.(bool); ok && v {
				return "true", nil
			}
			return "false", nil
		}
		return b.generateExpr(expr)
	default:
		// For other expressions, wrap in test
		exprStr, err := b.generateExpr(expr)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("[[ -n \"%s\" ]]", exprStr), nil
	}
}

// generateExpr generates an expression and returns its string representation
func (b *BashBackend) generateExpr(expr ir.Expression) (string, error) {
	switch e := expr.(type) {
	case *ir.LiteralExpr:
		return b.generateLiteral(e)
	case *ir.VarRefExpr:
		return b.generateVarRef(e)
	case *ir.BinaryExpr:
		return b.generateBinaryExpr(e)
	case *ir.UnaryExpr:
		return b.generateUnaryExpr(e)
	case *ir.MessageSendExpr:
		return b.generateMessageSend(e)
	case *ir.BlockExpr:
		return b.generateBlockExpr(e)
	case *ir.SubshellExpr:
		return b.generateSubshell(e)
	case *ir.SelfExpr:
		return "$_RECEIVER", nil
	case *ir.ClassRefExpr:
		return e.FullName(), nil
	case *ir.JSONPrimitiveExpr:
		return b.generateJSONPrimitive(e)
	default:
		return "", fmt.Errorf("unsupported expression type: %T", expr)
	}
}

// generateLiteral generates a literal value
func (b *BashBackend) generateLiteral(e *ir.LiteralExpr) (string, error) {
	switch e.Type_ {
	case ir.TypeInt:
		return fmt.Sprintf("%v", e.Value), nil
	case ir.TypeString:
		return fmt.Sprintf("%v", e.Value), nil
	case ir.TypeBool:
		if v, ok := e.Value.(bool); ok && v {
			return "true", nil
		}
		return "false", nil
	case ir.TypeJSON:
		// JSON values need to be properly quoted
		return fmt.Sprintf("%v", e.Value), nil
	default:
		return fmt.Sprintf("%v", e.Value), nil
	}
}

// generateVarRef generates a variable reference
func (b *BashBackend) generateVarRef(e *ir.VarRefExpr) (string, error) {
	switch e.Kind {
	case ir.VarIVar:
		return fmt.Sprintf("$(_ivar %s)", e.Name), nil
	case ir.VarClassVar:
		return fmt.Sprintf("${__%s__%s}", b.className(), e.Name), nil
	case ir.VarLocal, ir.VarParam:
		return fmt.Sprintf("$%s", e.Name), nil
	case ir.VarGlobal:
		return fmt.Sprintf("$%s", e.Name), nil
	default:
		return fmt.Sprintf("$%s", e.Name), nil
	}
}

// generateBinaryExpr generates a binary expression
func (b *BashBackend) generateBinaryExpr(e *ir.BinaryExpr) (string, error) {
	left, err := b.generateExpr(e.Left)
	if err != nil {
		return "", err
	}
	right, err := b.generateExpr(e.Right)
	if err != nil {
		return "", err
	}

	// Arithmetic operations use $((...))
	switch e.Op {
	case "+", "-", "*", "/", "%":
		return fmt.Sprintf("$(( %s %s %s ))", left, e.Op, right), nil
	case "==", "!=", "<", ">", "<=", ">=":
		// Comparison in arithmetic context
		return fmt.Sprintf("$(( %s %s %s ))", left, e.Op, right), nil
	case "&&", "||":
		return fmt.Sprintf("%s %s %s", left, e.Op, right), nil
	default:
		return fmt.Sprintf("%s %s %s", left, e.Op, right), nil
	}
}

// generateUnaryExpr generates a unary expression
func (b *BashBackend) generateUnaryExpr(e *ir.UnaryExpr) (string, error) {
	operand, err := b.generateExpr(e.Operand)
	if err != nil {
		return "", err
	}

	switch e.Op {
	case "!":
		return fmt.Sprintf("! %s", operand), nil
	case "-":
		return fmt.Sprintf("$(( -%s ))", operand), nil
	default:
		return fmt.Sprintf("%s%s", e.Op, operand), nil
	}
}

// generateMessageSend generates a message send expression
func (b *BashBackend) generateMessageSend(e *ir.MessageSendExpr) (string, error) {
	var receiver string
	var err error

	if e.IsSelfSend {
		receiver = "\"$_RECEIVER\""
	} else if e.IsClassSend {
		receiver = e.TargetClass
	} else {
		receiver, err = b.generateExpr(e.Receiver)
		if err != nil {
			return "", err
		}
		// Wrap in quotes if it's a variable
		if strings.HasPrefix(receiver, "$") {
			receiver = fmt.Sprintf("\"%s\"", receiver)
		}
	}

	// Build selector (replace : with _)
	selector := selectorToBashName(e.Selector)

	// Build args
	var args []string
	for _, arg := range e.Args {
		argStr, err := b.generateExpr(arg)
		if err != nil {
			return "", err
		}
		args = append(args, argStr)
	}

	if len(args) > 0 {
		return fmt.Sprintf("$(@ %s %s %s)", receiver, selector, strings.Join(args, " ")), nil
	}
	return fmt.Sprintf("$(@ %s %s)", receiver, selector), nil
}

// generateBlockExpr generates a block/closure expression
func (b *BashBackend) generateBlockExpr(e *ir.BlockExpr) (string, error) {
	// Blocks in Bash are represented as functions or inline code
	// For now, generate a subshell with the block body
	var body strings.Builder

	for _, stmt := range e.Body {
		// This is a simplification - real implementation would be more complex
		stmtStr := fmt.Sprintf("%v", stmt)
		body.WriteString(stmtStr)
	}

	if len(e.Params) > 0 {
		return fmt.Sprintf("{ %s; }", body.String()), nil
	}
	return fmt.Sprintf("{ %s; }", body.String()), nil
}

// generateSubshell generates a subshell expression
func (b *BashBackend) generateSubshell(e *ir.SubshellExpr) (string, error) {
	return fmt.Sprintf("$(%s)", e.Code), nil
}

// generateJSONPrimitive generates a JSON primitive operation
func (b *BashBackend) generateJSONPrimitive(e *ir.JSONPrimitiveExpr) (string, error) {
	receiver, err := b.generateExpr(e.Receiver)
	if err != nil {
		return "", err
	}

	switch e.Operation {
	case "arrayAt":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("arrayAt requires index argument")
		}
		idx, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -r --argjson i \"%s\" '.[$i] // empty')", receiver, idx), nil

	case "arrayPush":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("arrayPush requires value argument")
		}
		val, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -c --arg v \"%s\" '. + [$v]')", receiver, val), nil

	case "arrayLength":
		return fmt.Sprintf("$(echo \"%s\" | jq 'length')", receiver), nil

	case "arrayFirst":
		return fmt.Sprintf("$(echo \"%s\" | jq -r '.[0] // empty')", receiver), nil

	case "arrayLast":
		return fmt.Sprintf("$(echo \"%s\" | jq -r '.[-1] // empty')", receiver), nil

	case "arrayAtPut":
		if len(e.Args) < 2 {
			return "", fmt.Errorf("arrayAtPut requires index and value arguments")
		}
		idx, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		val, err := b.generateExpr(e.Args[1])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -c --argjson i \"%s\" --arg v \"%s\" '.[$i] = $v')", receiver, idx, val), nil

	case "arrayRemoveAt":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("arrayRemoveAt requires index argument")
		}
		idx, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -c --argjson i \"%s\" 'del(.[$i])')", receiver, idx), nil

	case "objectAt":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("objectAt requires key argument")
		}
		key, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -r --arg k \"%s\" '.[$k] // empty')", receiver, key), nil

	case "objectAtPut":
		if len(e.Args) < 2 {
			return "", fmt.Errorf("objectAtPut requires key and value arguments")
		}
		key, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		val, err := b.generateExpr(e.Args[1])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -c --arg k \"%s\" --arg v \"%s\" '. + {($k): $v}')", receiver, key, val), nil

	case "arrayIsEmpty":
		return fmt.Sprintf("$(echo \"%s\" | jq 'length == 0')", receiver), nil

	case "objectLength":
		return fmt.Sprintf("$(echo \"%s\" | jq 'length')", receiver), nil

	case "objectIsEmpty":
		return fmt.Sprintf("$(echo \"%s\" | jq 'length == 0')", receiver), nil

	case "objectHasKey":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("objectHasKey requires key argument")
		}
		key, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -r --arg k \"%s\" 'has($k)')", receiver, key), nil

	case "objectKeys":
		return fmt.Sprintf("$(echo \"%s\" | jq -c 'keys')", receiver), nil

	case "objectValues":
		return fmt.Sprintf("$(echo \"%s\" | jq -c '[.[]]')", receiver), nil

	case "objectRemoveKey":
		if len(e.Args) < 1 {
			return "", fmt.Errorf("objectRemoveKey requires key argument")
		}
		key, err := b.generateExpr(e.Args[0])
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("$(echo \"%s\" | jq -c --arg k \"%s\" 'del(.[$k])')", receiver, key), nil

	default:
		return "", fmt.Errorf("unsupported JSON operation: %s", e.Operation)
	}
}

// Helper methods

// className returns the class name for function naming
func (b *BashBackend) className() string {
	if b.prog.Package != "" {
		return b.prog.Package + "__" + b.prog.Name
	}
	return b.prog.Name
}

// methodFuncName converts a method to its Bash function name suffix
func (b *BashBackend) methodFuncName(m *ir.Method) string {
	selector := selectorToBashName(m.Selector)

	if m.Kind == ir.ClassMethod {
		return "class__" + selector
	}
	return selector
}

// selectorToBashName converts a selector like "at:put:" to "at_put_"
func selectorToBashName(selector string) string {
	return strings.ReplaceAll(selector, ":", "_")
}

// formatInstanceVars formats instance variables for metadata
func (b *BashBackend) formatInstanceVars() string {
	var parts []string
	for _, iv := range b.prog.InstanceVars {
		defaultVal := ""
		if iv.Default.Raw != "" {
			defaultVal = iv.Default.Raw
		}
		parts = append(parts, fmt.Sprintf("%s:%s", iv.Name, defaultVal))
	}
	return strings.Join(parts, " ")
}

// computeSourceHash computes a hash for the source (placeholder)
func (b *BashBackend) computeSourceHash() string {
	// In a real implementation, this would hash the actual source
	// For now, hash the program structure
	data := fmt.Sprintf("%s%s%v", b.prog.Name, b.prog.Parent, b.prog.Traits)
	hash := sha256.Sum256([]byte(data))
	return hex.EncodeToString(hash[:])
}

// writeln writes a line with current indentation
func (b *BashBackend) writeln(s string) {
	b.buf.WriteString(strings.Repeat("  ", b.indent))
	b.buf.WriteString(s)
	b.buf.WriteString("\n")
}

// writef writes a formatted string with current indentation
func (b *BashBackend) writef(format string, args ...interface{}) {
	b.buf.WriteString(strings.Repeat("  ", b.indent))
	fmt.Fprintf(&b.buf, format, args...)
}

// stripDollar removes the leading $ from a variable reference
func stripDollar(s string) string {
	if strings.HasPrefix(s, "$") {
		return s[1:]
	}
	return s
}

// isArithmeticExpr returns true if the expression is an arithmetic operation
func isArithmeticExpr(expr ir.Expression) bool {
	switch e := expr.(type) {
	case *ir.BinaryExpr:
		switch e.Op {
		case "+", "-", "*", "/", "%":
			return true
		}
	case *ir.UnaryExpr:
		if e.Op == "-" {
			return true
		}
	}
	return false
}

// generateArithExpr generates an arithmetic expression without the $(( )) wrapper
// This is used inside (( )) commands for Procyon compatibility
func (b *BashBackend) generateArithExpr(expr ir.Expression) (string, error) {
	switch e := expr.(type) {
	case *ir.BinaryExpr:
		left, err := b.generateArithExpr(e.Left)
		if err != nil {
			return "", err
		}
		right, err := b.generateArithExpr(e.Right)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("(%s %s %s)", left, e.Op, right), nil
	case *ir.UnaryExpr:
		operand, err := b.generateArithExpr(e.Operand)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("(-%s)", operand), nil
	case *ir.VarRefExpr:
		switch e.Kind {
		case ir.VarIVar:
			return fmt.Sprintf("$(_ivar %s)", e.Name), nil
		case ir.VarClassVar:
			return fmt.Sprintf("${__%s__%s}", b.className(), e.Name), nil
		default:
			return fmt.Sprintf("$%s", e.Name), nil
		}
	case *ir.LiteralExpr:
		return fmt.Sprintf("%v", e.Value), nil
	default:
		// Fall back to regular expression generation
		return b.generateExpr(expr)
	}
}
